<html lang="en">
<head>
<title>Expression trees - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Trees.html#Trees" title="Trees">
<link rel="prev" href="Attributes.html#Attributes" title="Attributes">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Expression-trees"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Attributes.html#Attributes">Attributes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Trees.html#Trees">Trees</a>
<hr>
</div>

<h3 class="section">9.8 Expressions</h3>

<p><a name="index-expression-465"></a><a name="index-TREE_005fTYPE-466"></a><a name="index-TREE_005fOPERAND-467"></a><a name="index-INTEGER_005fCST-468"></a><a name="index-TREE_005fINT_005fCST_005fHIGH-469"></a><a name="index-TREE_005fINT_005fCST_005fLOW-470"></a><a name="index-tree_005fint_005fcst_005flt-471"></a><a name="index-tree_005fint_005fcst_005fequal-472"></a><a name="index-REAL_005fCST-473"></a><a name="index-COMPLEX_005fCST-474"></a><a name="index-VECTOR_005fCST-475"></a><a name="index-STRING_005fCST-476"></a><a name="index-TREE_005fSTRING_005fLENGTH-477"></a><a name="index-TREE_005fSTRING_005fPOINTER-478"></a><a name="index-PTRMEM_005fCST-479"></a><a name="index-PTRMEM_005fCST_005fCLASS-480"></a><a name="index-PTRMEM_005fCST_005fMEMBER-481"></a><a name="index-VAR_005fDECL-482"></a><a name="index-NEGATE_005fEXPR-483"></a><a name="index-ABS_005fEXPR-484"></a><a name="index-BIT_005fNOT_005fEXPR-485"></a><a name="index-TRUTH_005fNOT_005fEXPR-486"></a><a name="index-PREDECREMENT_005fEXPR-487"></a><a name="index-PREINCREMENT_005fEXPR-488"></a><a name="index-POSTDECREMENT_005fEXPR-489"></a><a name="index-POSTINCREMENT_005fEXPR-490"></a><a name="index-ADDR_005fEXPR-491"></a><a name="index-INDIRECT_005fREF-492"></a><a name="index-FIX_005fTRUNC_005fEXPR-493"></a><a name="index-FLOAT_005fEXPR-494"></a><a name="index-COMPLEX_005fEXPR-495"></a><a name="index-CONJ_005fEXPR-496"></a><a name="index-REALPART_005fEXPR-497"></a><a name="index-IMAGPART_005fEXPR-498"></a><a name="index-NON_005fLVALUE_005fEXPR-499"></a><a name="index-NOP_005fEXPR-500"></a><a name="index-CONVERT_005fEXPR-501"></a><a name="index-THROW_005fEXPR-502"></a><a name="index-LSHIFT_005fEXPR-503"></a><a name="index-RSHIFT_005fEXPR-504"></a><a name="index-BIT_005fIOR_005fEXPR-505"></a><a name="index-BIT_005fXOR_005fEXPR-506"></a><a name="index-BIT_005fAND_005fEXPR-507"></a><a name="index-TRUTH_005fANDIF_005fEXPR-508"></a><a name="index-TRUTH_005fORIF_005fEXPR-509"></a><a name="index-TRUTH_005fAND_005fEXPR-510"></a><a name="index-TRUTH_005fOR_005fEXPR-511"></a><a name="index-TRUTH_005fXOR_005fEXPR-512"></a><a name="index-PLUS_005fEXPR-513"></a><a name="index-MINUS_005fEXPR-514"></a><a name="index-MULT_005fEXPR-515"></a><a name="index-RDIV_005fEXPR-516"></a><a name="index-TRUNC_005fDIV_005fEXPR-517"></a><a name="index-FLOOR_005fDIV_005fEXPR-518"></a><a name="index-CEIL_005fDIV_005fEXPR-519"></a><a name="index-ROUND_005fDIV_005fEXPR-520"></a><a name="index-TRUNC_005fMOD_005fEXPR-521"></a><a name="index-FLOOR_005fMOD_005fEXPR-522"></a><a name="index-CEIL_005fMOD_005fEXPR-523"></a><a name="index-ROUND_005fMOD_005fEXPR-524"></a><a name="index-EXACT_005fDIV_005fEXPR-525"></a><a name="index-ARRAY_005fREF-526"></a><a name="index-ARRAY_005fRANGE_005fREF-527"></a><a name="index-TARGET_005fMEM_005fREF-528"></a><a name="index-LT_005fEXPR-529"></a><a name="index-LE_005fEXPR-530"></a><a name="index-GT_005fEXPR-531"></a><a name="index-GE_005fEXPR-532"></a><a name="index-EQ_005fEXPR-533"></a><a name="index-NE_005fEXPR-534"></a><a name="index-ORDERED_005fEXPR-535"></a><a name="index-UNORDERED_005fEXPR-536"></a><a name="index-UNLT_005fEXPR-537"></a><a name="index-UNLE_005fEXPR-538"></a><a name="index-UNGT_005fEXPR-539"></a><a name="index-UNGE_005fEXPR-540"></a><a name="index-UNEQ_005fEXPR-541"></a><a name="index-LTGT_005fEXPR-542"></a><a name="index-MODIFY_005fEXPR-543"></a><a name="index-INIT_005fEXPR-544"></a><a name="index-COMPONENT_005fREF-545"></a><a name="index-COMPOUND_005fEXPR-546"></a><a name="index-COND_005fEXPR-547"></a><a name="index-CALL_005fEXPR-548"></a><a name="index-STMT_005fEXPR-549"></a><a name="index-BIND_005fEXPR-550"></a><a name="index-LOOP_005fEXPR-551"></a><a name="index-EXIT_005fEXPR-552"></a><a name="index-CLEANUP_005fPOINT_005fEXPR-553"></a><a name="index-CONSTRUCTOR-554"></a><a name="index-COMPOUND_005fLITERAL_005fEXPR-555"></a><a name="index-SAVE_005fEXPR-556"></a><a name="index-TARGET_005fEXPR-557"></a><a name="index-AGGR_005fINIT_005fEXPR-558"></a><a name="index-VA_005fARG_005fEXPR-559"></a>
The internal representation for expressions is for the most part quite
straightforward.  However, there are a few facts that one must bear in
mind.  In particular, the expression &ldquo;tree&rdquo; is actually a directed
acyclic graph.  (For example there may be many references to the integer
constant zero throughout the source program; many of these will be
represented by the same expression node.)  You should not rely on
certain kinds of node being shared, nor should rely on certain kinds of
nodes being unshared.

 <p>The following macros can be used with all expression nodes:

     <dl>
<dt><code>TREE_TYPE</code><a name="index-TREE_005fTYPE-560"></a><dd>Returns the type of the expression.  This value may not be precisely the
same type that would be given the expression in the original program. 
</dl>

 <p>In what follows, some nodes that one might expect to always have type
<code>bool</code> are documented to have either integral or boolean type.  At
some point in the future, the C front end may also make use of this same
intermediate representation, and at this point these nodes will
certainly have integral type.  The previous sentence is not meant to
imply that the C++ front end does not or will not give these nodes
integral type.

 <p>Below, we list the various kinds of expression nodes.  Except where
noted otherwise, the operands to an expression are accessed using the
<code>TREE_OPERAND</code> macro.  For example, to access the first operand to
a binary plus expression <code>expr</code>, use:

<pre class="smallexample">     TREE_OPERAND (expr, 0)
</pre>
 <p class="noindent">As this example indicates, the operands are zero-indexed.

 <p>The table below begins with constants, moves on to unary expressions,
then proceeds to binary expressions, and concludes with various other
kinds of expressions:

     <dl>
<dt><code>INTEGER_CST</code><dd>These nodes represent integer constants.  Note that the type of these
constants is obtained with <code>TREE_TYPE</code>; they are not always of type
<code>int</code>.  In particular, <code>char</code> constants are represented with
<code>INTEGER_CST</code> nodes.  The value of the integer constant <code>e</code> is
given by
     <pre class="smallexample">          ((TREE_INT_CST_HIGH (e) &lt;&lt; HOST_BITS_PER_WIDE_INT)
          + TREE_INST_CST_LOW (e))
     </pre>
     <p class="noindent">HOST_BITS_PER_WIDE_INT is at least thirty-two on all platforms.  Both
<code>TREE_INT_CST_HIGH</code> and <code>TREE_INT_CST_LOW</code> return a
<code>HOST_WIDE_INT</code>.  The value of an <code>INTEGER_CST</code> is interpreted
as a signed or unsigned quantity depending on the type of the constant. 
In general, the expression given above will overflow, so it should not
be used to calculate the value of the constant.

     <p>The variable <code>integer_zero_node</code> is an integer constant with value
zero.  Similarly, <code>integer_one_node</code> is an integer constant with
value one.  The <code>size_zero_node</code> and <code>size_one_node</code> variables
are analogous, but have type <code>size_t</code> rather than <code>int</code>.

     <p>The function <code>tree_int_cst_lt</code> is a predicate which holds if its
first argument is less than its second.  Both constants are assumed to
have the same signedness (i.e., either both should be signed or both
should be unsigned.)  The full width of the constant is used when doing
the comparison; the usual rules about promotions and conversions are
ignored.  Similarly, <code>tree_int_cst_equal</code> holds if the two
constants are equal.  The <code>tree_int_cst_sgn</code> function returns the
sign of a constant.  The value is <code>1</code>, <code>0</code>, or <code>-1</code>
according on whether the constant is greater than, equal to, or less
than zero.  Again, the signedness of the constant's type is taken into
account; an unsigned constant is never less than zero, no matter what
its bit-pattern.

     <br><dt><code>REAL_CST</code><dd>
FIXME: Talk about how to obtain representations of this constant, do
comparisons, and so forth.

     <br><dt><code>COMPLEX_CST</code><dd>These nodes are used to represent complex number constants, that is a
<code>__complex__</code> whose parts are constant nodes.  The
<code>TREE_REALPART</code> and <code>TREE_IMAGPART</code> return the real and the
imaginary parts respectively.

     <br><dt><code>VECTOR_CST</code><dd>These nodes are used to represent vector constants, whose parts are
constant nodes.  Each individual constant node is either an integer or a
double constant node.  The first operand is a <code>TREE_LIST</code> of the
constant nodes and is accessed through <code>TREE_VECTOR_CST_ELTS</code>.

     <br><dt><code>STRING_CST</code><dd>These nodes represent string-constants.  The <code>TREE_STRING_LENGTH</code>
returns the length of the string, as an <code>int</code>.  The
<code>TREE_STRING_POINTER</code> is a <code>char*</code> containing the string
itself.  The string may not be <code>NUL</code>-terminated, and it may contain
embedded <code>NUL</code> characters.  Therefore, the
<code>TREE_STRING_LENGTH</code> includes the trailing <code>NUL</code> if it is
present.

     <p>For wide string constants, the <code>TREE_STRING_LENGTH</code> is the number
of bytes in the string, and the <code>TREE_STRING_POINTER</code>
points to an array of the bytes of the string, as represented on the
target system (that is, as integers in the target endianness).  Wide and
non-wide string constants are distinguished only by the <code>TREE_TYPE</code>
of the <code>STRING_CST</code>.

     <p>FIXME: The formats of string constants are not well-defined when the
target system bytes are not the same width as host system bytes.

     <br><dt><code>PTRMEM_CST</code><dd>These nodes are used to represent pointer-to-member constants.  The
<code>PTRMEM_CST_CLASS</code> is the class type (either a <code>RECORD_TYPE</code>
or <code>UNION_TYPE</code> within which the pointer points), and the
<code>PTRMEM_CST_MEMBER</code> is the declaration for the pointed to object. 
Note that the <code>DECL_CONTEXT</code> for the <code>PTRMEM_CST_MEMBER</code> is in
general different from the <code>PTRMEM_CST_CLASS</code>.  For example,
given:
     <pre class="smallexample">          struct B { int i; };
          struct D : public B {};
          int D::*dp = &amp;D::i;
     </pre>
     <p class="noindent">The <code>PTRMEM_CST_CLASS</code> for <code>&amp;D::i</code> is <code>D</code>, even though
the <code>DECL_CONTEXT</code> for the <code>PTRMEM_CST_MEMBER</code> is <code>B</code>,
since <code>B::i</code> is a member of <code>B</code>, not <code>D</code>.

     <br><dt><code>VAR_DECL</code><dd>
These nodes represent variables, including static data members.  For
more information, see <a href="Declarations.html#Declarations">Declarations</a>.

     <br><dt><code>NEGATE_EXPR</code><dd>These nodes represent unary negation of the single operand, for both
integer and floating-point types.  The type of negation can be
determined by looking at the type of the expression.

     <p>The behavior of this operation on signed arithmetic overflow is
controlled by the <code>flag_wrapv</code> and <code>flag_trapv</code> variables.

     <br><dt><code>ABS_EXPR</code><dd>These nodes represent the absolute value of the single operand, for
both integer and floating-point types.  This is typically used to
implement the <code>abs</code>, <code>labs</code> and <code>llabs</code> builtins for
integer types, and the <code>fabs</code>, <code>fabsf</code> and <code>fabsl</code>
builtins for floating point types.  The type of abs operation can
be determined by looking at the type of the expression.

     <p>This node is not used for complex types.  To represent the modulus
or complex abs of a complex value, use the <code>BUILT_IN_CABS</code>,
<code>BUILT_IN_CABSF</code> or <code>BUILT_IN_CABSL</code> builtins, as used
to implement the C99 <code>cabs</code>, <code>cabsf</code> and <code>cabsl</code>
built-in functions.

     <br><dt><code>BIT_NOT_EXPR</code><dd>These nodes represent bitwise complement, and will always have integral
type.  The only operand is the value to be complemented.

     <br><dt><code>TRUTH_NOT_EXPR</code><dd>These nodes represent logical negation, and will always have integral
(or boolean) type.  The operand is the value being negated.  The type
of the operand and that of the result are always of <code>BOOLEAN_TYPE</code>
or <code>INTEGER_TYPE</code>.

     <br><dt><code>PREDECREMENT_EXPR</code><dt><code>PREINCREMENT_EXPR</code><dt><code>POSTDECREMENT_EXPR</code><dt><code>POSTINCREMENT_EXPR</code><dd>These nodes represent increment and decrement expressions.  The value of
the single operand is computed, and the operand incremented or
decremented.  In the case of <code>PREDECREMENT_EXPR</code> and
<code>PREINCREMENT_EXPR</code>, the value of the expression is the value
resulting after the increment or decrement; in the case of
<code>POSTDECREMENT_EXPR</code> and <code>POSTINCREMENT_EXPR</code> is the value
before the increment or decrement occurs.  The type of the operand, like
that of the result, will be either integral, boolean, or floating-point.

     <br><dt><code>ADDR_EXPR</code><dd>These nodes are used to represent the address of an object.  (These
expressions will always have pointer or reference type.)  The operand may
be another expression, or it may be a declaration.

     <p>As an extension, GCC allows users to take the address of a label.  In
this case, the operand of the <code>ADDR_EXPR</code> will be a
<code>LABEL_DECL</code>.  The type of such an expression is <code>void*</code>.

     <p>If the object addressed is not an lvalue, a temporary is created, and
the address of the temporary is used.

     <br><dt><code>INDIRECT_REF</code><dd>These nodes are used to represent the object pointed to by a pointer. 
The operand is the pointer being dereferenced; it will always have
pointer or reference type.

     <br><dt><code>FIX_TRUNC_EXPR</code><dd>These nodes represent conversion of a floating-point value to an
integer.  The single operand will have a floating-point type, while the
the complete expression will have an integral (or boolean) type.  The
operand is rounded towards zero.

     <br><dt><code>FLOAT_EXPR</code><dd>These nodes represent conversion of an integral (or boolean) value to a
floating-point value.  The single operand will have integral type, while
the complete expression will have a floating-point type.

     <p>FIXME: How is the operand supposed to be rounded?  Is this dependent on
<samp><span class="option">-mieee</span></samp>?

     <br><dt><code>COMPLEX_EXPR</code><dd>These nodes are used to represent complex numbers constructed from two
expressions of the same (integer or real) type.  The first operand is the
real part and the second operand is the imaginary part.

     <br><dt><code>CONJ_EXPR</code><dd>These nodes represent the conjugate of their operand.

     <br><dt><code>REALPART_EXPR</code><dt><code>IMAGPART_EXPR</code><dd>These nodes represent respectively the real and the imaginary parts
of complex numbers (their sole argument).

     <br><dt><code>NON_LVALUE_EXPR</code><dd>These nodes indicate that their one and only operand is not an lvalue. 
A back end can treat these identically to the single operand.

     <br><dt><code>NOP_EXPR</code><dd>These nodes are used to represent conversions that do not require any
code-generation.  For example, conversion of a <code>char*</code> to an
<code>int*</code> does not require any code be generated; such a conversion is
represented by a <code>NOP_EXPR</code>.  The single operand is the expression
to be converted.  The conversion from a pointer to a reference is also
represented with a <code>NOP_EXPR</code>.

     <br><dt><code>CONVERT_EXPR</code><dd>These nodes are similar to <code>NOP_EXPR</code>s, but are used in those
situations where code may need to be generated.  For example, if an
<code>int*</code> is converted to an <code>int</code> code may need to be generated
on some platforms.  These nodes are never used for C++-specific
conversions, like conversions between pointers to different classes in
an inheritance hierarchy.  Any adjustments that need to be made in such
cases are always indicated explicitly.  Similarly, a user-defined
conversion is never represented by a <code>CONVERT_EXPR</code>; instead, the
function calls are made explicit.

     <br><dt><code>THROW_EXPR</code><dd>These nodes represent <code>throw</code> expressions.  The single operand is
an expression for the code that should be executed to throw the
exception.  However, there is one implicit action not represented in
that expression; namely the call to <code>__throw</code>.  This function takes
no arguments.  If <code>setjmp</code>/<code>longjmp</code> exceptions are used, the
function <code>__sjthrow</code> is called instead.  The normal GCC back end
uses the function <code>emit_throw</code> to generate this code; you can
examine this function to see what needs to be done.

     <br><dt><code>LSHIFT_EXPR</code><dt><code>RSHIFT_EXPR</code><dd>These nodes represent left and right shifts, respectively.  The first
operand is the value to shift; it will always be of integral type.  The
second operand is an expression for the number of bits by which to
shift.  Right shift should be treated as arithmetic, i.e., the
high-order bits should be zero-filled when the expression has unsigned
type and filled with the sign bit when the expression has signed type. 
Note that the result is undefined if the second operand is larger
than or equal to the first operand's type size.

     <br><dt><code>BIT_IOR_EXPR</code><dt><code>BIT_XOR_EXPR</code><dt><code>BIT_AND_EXPR</code><dd>These nodes represent bitwise inclusive or, bitwise exclusive or, and
bitwise and, respectively.  Both operands will always have integral
type.

     <br><dt><code>TRUTH_ANDIF_EXPR</code><dt><code>TRUTH_ORIF_EXPR</code><dd>These nodes represent logical and and logical or, respectively.  These
operators are not strict; i.e., the second operand is evaluated only if
the value of the expression is not determined by evaluation of the first
operand.  The type of the operands and that of the result are always of
<code>BOOLEAN_TYPE</code> or <code>INTEGER_TYPE</code>.

     <br><dt><code>TRUTH_AND_EXPR</code><dt><code>TRUTH_OR_EXPR</code><dt><code>TRUTH_XOR_EXPR</code><dd>These nodes represent logical and, logical or, and logical exclusive or. 
They are strict; both arguments are always evaluated.  There are no
corresponding operators in C or C++, but the front end will sometimes
generate these expressions anyhow, if it can tell that strictness does
not matter.  The type of the operands and that of the result are
always of <code>BOOLEAN_TYPE</code> or <code>INTEGER_TYPE</code>.

     <dt><code>PLUS_EXPR</code><dt><code>MINUS_EXPR</code><dt><code>MULT_EXPR</code><dd>These nodes represent various binary arithmetic operations. 
Respectively, these operations are addition, subtraction (of the second
operand from the first) and multiplication.  Their operands may have
either integral or floating type, but there will never be case in which
one operand is of floating type and the other is of integral type.

     <p>The behavior of these operations on signed arithmetic overflow is
controlled by the <code>flag_wrapv</code> and <code>flag_trapv</code> variables.

     <br><dt><code>RDIV_EXPR</code><dd>This node represents a floating point division operation.

     <br><dt><code>TRUNC_DIV_EXPR</code><dt><code>FLOOR_DIV_EXPR</code><dt><code>CEIL_DIV_EXPR</code><dt><code>ROUND_DIV_EXPR</code><dd>These nodes represent integer division operations that return an integer
result.  <code>TRUNC_DIV_EXPR</code> rounds towards zero, <code>FLOOR_DIV_EXPR</code>
rounds towards negative infinity, <code>CEIL_DIV_EXPR</code> rounds towards
positive infinity and <code>ROUND_DIV_EXPR</code> rounds to the closest integer. 
Integer division in C and C++ is truncating, i.e. <code>TRUNC_DIV_EXPR</code>.

     <p>The behavior of these operations on signed arithmetic overflow, when
dividing the minimum signed integer by minus one, is controlled by the
<code>flag_wrapv</code> and <code>flag_trapv</code> variables.

     <br><dt><code>TRUNC_MOD_EXPR</code><dt><code>FLOOR_MOD_EXPR</code><dt><code>CEIL_MOD_EXPR</code><dt><code>ROUND_MOD_EXPR</code><dd>These nodes represent the integer remainder or modulus operation. 
The integer modulus of two operands <code>a</code> and <code>b</code> is
defined as <code>a - (a/b)*b</code> where the division calculated using
the corresponding division operator.  Hence for <code>TRUNC_MOD_EXPR</code>
this definition assumes division using truncation towards zero, i.e. 
<code>TRUNC_DIV_EXPR</code>.  Integer remainder in C and C++ uses truncating
division, i.e. <code>TRUNC_MOD_EXPR</code>.

     <br><dt><code>EXACT_DIV_EXPR</code><dd>The <code>EXACT_DIV_EXPR</code> code is used to represent integer divisions where
the numerator is known to be an exact multiple of the denominator.  This
allows the backend to choose between the faster of <code>TRUNC_DIV_EXPR</code>,
<code>CEIL_DIV_EXPR</code> and <code>FLOOR_DIV_EXPR</code> for the current target.

     <br><dt><code>ARRAY_REF</code><dd>These nodes represent array accesses.  The first operand is the array;
the second is the index.  To calculate the address of the memory
accessed, you must scale the index by the size of the type of the array
elements.  The type of these expressions must be the type of a component of
the array.  The third and fourth operands are used after gimplification
to represent the lower bound and component size but should not be used
directly; call <code>array_ref_low_bound</code> and <code>array_ref_element_size</code>
instead.

     <br><dt><code>ARRAY_RANGE_REF</code><dd>These nodes represent access to a range (or &ldquo;slice&rdquo;) of an array.  The
operands are the same as that for <code>ARRAY_REF</code> and have the same
meanings.  The type of these expressions must be an array whose component
type is the same as that of the first operand.  The range of that array
type determines the amount of data these expressions access.

     <br><dt><code>TARGET_MEM_REF</code><dd>These nodes represent memory accesses whose address directly map to
an addressing mode of the target architecture.  The first argument
is <code>TMR_SYMBOL</code> and must be a <code>VAR_DECL</code> of an object with
a fixed address.  The second argument is <code>TMR_BASE</code> and the
third one is <code>TMR_INDEX</code>.  The fourth argument is
<code>TMR_STEP</code> and must be an <code>INTEGER_CST</code>.  The fifth
argument is <code>TMR_OFFSET</code> and must be an <code>INTEGER_CST</code>. 
Any of the arguments may be NULL if the appropriate component
does not appear in the address.  Address of the <code>TARGET_MEM_REF</code>
is determined in the following way.

     <pre class="smallexample">          &amp;TMR_SYMBOL + TMR_BASE + TMR_INDEX * TMR_STEP + TMR_OFFSET
     </pre>
     <p>The sixth argument is the reference to the original memory access, which
is preserved for the purposes of the RTL alias analysis.  The seventh
argument is a tag representing the results of tree level alias analysis.

     <br><dt><code>LT_EXPR</code><dt><code>LE_EXPR</code><dt><code>GT_EXPR</code><dt><code>GE_EXPR</code><dt><code>EQ_EXPR</code><dt><code>NE_EXPR</code><dd>These nodes represent the less than, less than or equal to, greater
than, greater than or equal to, equal, and not equal comparison
operators.  The first and second operand with either be both of integral
type or both of floating type.  The result type of these expressions
will always be of integral or boolean type.  These operations return
the result type's zero value for false, and the result type's one value
for true.

     <p>For floating point comparisons, if we honor IEEE NaNs and either operand
is NaN, then <code>NE_EXPR</code> always returns true and the remaining operators
always return false.  On some targets, comparisons against an IEEE NaN,
other than equality and inequality, may generate a floating point exception.

     <br><dt><code>ORDERED_EXPR</code><dt><code>UNORDERED_EXPR</code><dd>These nodes represent non-trapping ordered and unordered comparison
operators.  These operations take two floating point operands and
determine whether they are ordered or unordered relative to each other. 
If either operand is an IEEE NaN, their comparison is defined to be
unordered, otherwise the comparison is defined to be ordered.  The
result type of these expressions will always be of integral or boolean
type.  These operations return the result type's zero value for false,
and the result type's one value for true.

     <br><dt><code>UNLT_EXPR</code><dt><code>UNLE_EXPR</code><dt><code>UNGT_EXPR</code><dt><code>UNGE_EXPR</code><dt><code>UNEQ_EXPR</code><dt><code>LTGT_EXPR</code><dd>These nodes represent the unordered comparison operators. 
These operations take two floating point operands and determine whether
the operands are unordered or are less than, less than or equal to,
greater than, greater than or equal to, or equal respectively.  For
example, <code>UNLT_EXPR</code> returns true if either operand is an IEEE
NaN or the first operand is less than the second.  With the possible
exception of <code>LTGT_EXPR</code>, all of these operations are guaranteed
not to generate a floating point exception.  The result
type of these expressions will always be of integral or boolean type. 
These operations return the result type's zero value for false,
and the result type's one value for true.

     <br><dt><code>MODIFY_EXPR</code><dd>These nodes represent assignment.  The left-hand side is the first
operand; the right-hand side is the second operand.  The left-hand side
will be a <code>VAR_DECL</code>, <code>INDIRECT_REF</code>, <code>COMPONENT_REF</code>, or
other lvalue.

     <p>These nodes are used to represent not only assignment with `<samp><span class="samp">=</span></samp>' but
also compound assignments (like `<samp><span class="samp">+=</span></samp>'), by reduction to `<samp><span class="samp">=</span></samp>'
assignment.  In other words, the representation for `<samp><span class="samp">i += 3</span></samp>' looks
just like that for `<samp><span class="samp">i = i + 3</span></samp>'.

     <br><dt><code>INIT_EXPR</code><dd>These nodes are just like <code>MODIFY_EXPR</code>, but are used only when a
variable is initialized, rather than assigned to subsequently.  This
means that we can assume that the target of the initialization is not
used in computing its own value; any reference to the lhs in computing
the rhs is undefined.

     <br><dt><code>COMPONENT_REF</code><dd>These nodes represent non-static data member accesses.  The first
operand is the object (rather than a pointer to it); the second operand
is the <code>FIELD_DECL</code> for the data member.  The third operand represents
the byte offset of the field, but should not be used directly; call
<code>component_ref_field_offset</code> instead.

     <br><dt><code>COMPOUND_EXPR</code><dd>These nodes represent comma-expressions.  The first operand is an
expression whose value is computed and thrown away prior to the
evaluation of the second operand.  The value of the entire expression is
the value of the second operand.

     <br><dt><code>COND_EXPR</code><dd>These nodes represent <code>?:</code> expressions.  The first operand
is of boolean or integral type.  If it evaluates to a nonzero value,
the second operand should be evaluated, and returned as the value of the
expression.  Otherwise, the third operand is evaluated, and returned as
the value of the expression.

     <p>The second operand must have the same type as the entire expression,
unless it unconditionally throws an exception or calls a noreturn
function, in which case it should have void type.  The same constraints
apply to the third operand.  This allows array bounds checks to be
represented conveniently as <code>(i &gt;= 0 &amp;&amp; i &lt; 10) ? i : abort()</code>.

     <p>As a GNU extension, the C language front-ends allow the second
operand of the <code>?:</code> operator may be omitted in the source. 
For example, <code>x ? : 3</code> is equivalent to <code>x ? x : 3</code>,
assuming that <code>x</code> is an expression without side-effects. 
In the tree representation, however, the second operand is always
present, possibly protected by <code>SAVE_EXPR</code> if the first
argument does cause side-effects.

     <br><dt><code>CALL_EXPR</code><dd>These nodes are used to represent calls to functions, including
non-static member functions.  The first operand is a pointer to the
function to call; it is always an expression whose type is a
<code>POINTER_TYPE</code>.  The second argument is a <code>TREE_LIST</code>.  The
arguments to the call appear left-to-right in the list.  The
<code>TREE_VALUE</code> of each list node contains the expression
corresponding to that argument.  (The value of <code>TREE_PURPOSE</code> for
these nodes is unspecified, and should be ignored.)  For non-static
member functions, there will be an operand corresponding to the
<code>this</code> pointer.  There will always be expressions corresponding to
all of the arguments, even if the function is declared with default
arguments and some arguments are not explicitly provided at the call
sites.

     <br><dt><code>STMT_EXPR</code><dd>These nodes are used to represent GCC's statement-expression extension. 
The statement-expression extension allows code like this:
     <pre class="smallexample">          int f() { return ({ int j; j = 3; j + 7; }); }
     </pre>
     <p>In other words, an sequence of statements may occur where a single
expression would normally appear.  The <code>STMT_EXPR</code> node represents
such an expression.  The <code>STMT_EXPR_STMT</code> gives the statement
contained in the expression.  The value of the expression is the value
of the last sub-statement in the body.  More precisely, the value is the
value computed by the last statement nested inside <code>BIND_EXPR</code>,
<code>TRY_FINALLY_EXPR</code>, or <code>TRY_CATCH_EXPR</code>.  For example, in:
     <pre class="smallexample">          ({ 3; })
     </pre>
     <p>the value is <code>3</code> while in:
     <pre class="smallexample">          ({ if (x) { 3; } })
     </pre>
     <p>there is no value.  If the <code>STMT_EXPR</code> does not yield a value,
it's type will be <code>void</code>.

     <br><dt><code>BIND_EXPR</code><dd>These nodes represent local blocks.  The first operand is a list of
variables, connected via their <code>TREE_CHAIN</code> field.  These will
never require cleanups.  The scope of these variables is just the body
of the <code>BIND_EXPR</code>.  The body of the <code>BIND_EXPR</code> is the
second operand.

     <br><dt><code>LOOP_EXPR</code><dd>These nodes represent &ldquo;infinite&rdquo; loops.  The <code>LOOP_EXPR_BODY</code>
represents the body of the loop.  It should be executed forever, unless
an <code>EXIT_EXPR</code> is encountered.

     <br><dt><code>EXIT_EXPR</code><dd>These nodes represent conditional exits from the nearest enclosing
<code>LOOP_EXPR</code>.  The single operand is the condition; if it is
nonzero, then the loop should be exited.  An <code>EXIT_EXPR</code> will only
appear within a <code>LOOP_EXPR</code>.

     <br><dt><code>CLEANUP_POINT_EXPR</code><dd>These nodes represent full-expressions.  The single operand is an
expression to evaluate.  Any destructor calls engendered by the creation
of temporaries during the evaluation of that expression should be
performed immediately after the expression is evaluated.

     <br><dt><code>CONSTRUCTOR</code><dd>These nodes represent the brace-enclosed initializers for a structure or
array.  The first operand is reserved for use by the back end.  The
second operand is a <code>TREE_LIST</code>.  If the <code>TREE_TYPE</code> of the
<code>CONSTRUCTOR</code> is a <code>RECORD_TYPE</code> or <code>UNION_TYPE</code>, then
the <code>TREE_PURPOSE</code> of each node in the <code>TREE_LIST</code> will be a
<code>FIELD_DECL</code> and the <code>TREE_VALUE</code> of each node will be the
expression used to initialize that field.

     <p>If the <code>TREE_TYPE</code> of the <code>CONSTRUCTOR</code> is an
<code>ARRAY_TYPE</code>, then the <code>TREE_PURPOSE</code> of each element in the
<code>TREE_LIST</code> will be an <code>INTEGER_CST</code> or a <code>RANGE_EXPR</code> of
two <code>INTEGER_CST</code>s.  A single <code>INTEGER_CST</code> indicates which
element of the array (indexed from zero) is being assigned to.  A
<code>RANGE_EXPR</code> indicates an inclusive range of elements to
initialize.  In both cases the <code>TREE_VALUE</code> is the corresponding
initializer.  It is re-evaluated for each element of a
<code>RANGE_EXPR</code>.  If the <code>TREE_PURPOSE</code> is <code>NULL_TREE</code>, then
the initializer is for the next available array element.

     <p>In the front end, you should not depend on the fields appearing in any
particular order.  However, in the middle end, fields must appear in
declaration order.  You should not assume that all fields will be
represented.  Unrepresented fields will be set to zero.

     <br><dt><code>COMPOUND_LITERAL_EXPR</code><dd><a name="index-COMPOUND_005fLITERAL_005fEXPR_005fDECL_005fSTMT-561"></a><a name="index-COMPOUND_005fLITERAL_005fEXPR_005fDECL-562"></a>These nodes represent ISO C99 compound literals.  The
<code>COMPOUND_LITERAL_EXPR_DECL_STMT</code> is a <code>DECL_STMT</code>
containing an anonymous <code>VAR_DECL</code> for
the unnamed object represented by the compound literal; the
<code>DECL_INITIAL</code> of that <code>VAR_DECL</code> is a <code>CONSTRUCTOR</code>
representing the brace-enclosed list of initializers in the compound
literal.  That anonymous <code>VAR_DECL</code> can also be accessed directly
by the <code>COMPOUND_LITERAL_EXPR_DECL</code> macro.

     <br><dt><code>SAVE_EXPR</code><dd>
A <code>SAVE_EXPR</code> represents an expression (possibly involving
side-effects) that is used more than once.  The side-effects should
occur only the first time the expression is evaluated.  Subsequent uses
should just reuse the computed value.  The first operand to the
<code>SAVE_EXPR</code> is the expression to evaluate.  The side-effects should
be executed where the <code>SAVE_EXPR</code> is first encountered in a
depth-first preorder traversal of the expression tree.

     <br><dt><code>TARGET_EXPR</code><dd>A <code>TARGET_EXPR</code> represents a temporary object.  The first operand
is a <code>VAR_DECL</code> for the temporary variable.  The second operand is
the initializer for the temporary.  The initializer is evaluated and,
if non-void, copied (bitwise) into the temporary.  If the initializer
is void, that means that it will perform the initialization itself.

     <p>Often, a <code>TARGET_EXPR</code> occurs on the right-hand side of an
assignment, or as the second operand to a comma-expression which is
itself the right-hand side of an assignment, etc.  In this case, we say
that the <code>TARGET_EXPR</code> is &ldquo;normal&rdquo;; otherwise, we say it is
&ldquo;orphaned&rdquo;.  For a normal <code>TARGET_EXPR</code> the temporary variable
should be treated as an alias for the left-hand side of the assignment,
rather than as a new temporary variable.

     <p>The third operand to the <code>TARGET_EXPR</code>, if present, is a
cleanup-expression (i.e., destructor call) for the temporary.  If this
expression is orphaned, then this expression must be executed when the
statement containing this expression is complete.  These cleanups must
always be executed in the order opposite to that in which they were
encountered.  Note that if a temporary is created on one branch of a
conditional operator (i.e., in the second or third operand to a
<code>COND_EXPR</code>), the cleanup must be run only if that branch is
actually executed.

     <p>See <code>STMT_IS_FULL_EXPR_P</code> for more information about running these
cleanups.

     <br><dt><code>AGGR_INIT_EXPR</code><dd>An <code>AGGR_INIT_EXPR</code> represents the initialization as the return
value of a function call, or as the result of a constructor.  An
<code>AGGR_INIT_EXPR</code> will only appear as a full-expression, or as the
second operand of a <code>TARGET_EXPR</code>.  The first operand to the
<code>AGGR_INIT_EXPR</code> is the address of a function to call, just as in
a <code>CALL_EXPR</code>.  The second operand are the arguments to pass that
function, as a <code>TREE_LIST</code>, again in a manner similar to that of
a <code>CALL_EXPR</code>.

     <p>If <code>AGGR_INIT_VIA_CTOR_P</code> holds of the <code>AGGR_INIT_EXPR</code>, then
the initialization is via a constructor call.  The address of the third
operand of the <code>AGGR_INIT_EXPR</code>, which is always a <code>VAR_DECL</code>,
is taken, and this value replaces the first argument in the argument
list.

     <p>In either case, the expression is void.

     <br><dt><code>VA_ARG_EXPR</code><dd>This node is used to implement support for the C/C++ variable argument-list
mechanism.  It represents expressions like <code>va_arg (ap, type)</code>. 
Its <code>TREE_TYPE</code> yields the tree representation for <code>type</code> and
its sole argument yields the representation for <code>ap</code>.

 </dl>

<!-- Copyright (c) 2004, 2005 Free Software Foundation, Inc. -->
<!-- Free Software Foundation, Inc. -->
<!-- This is part of the GCC manual. -->
<!-- For copying conditions, see the file gcc.texi. -->
<!--  -->
<!-- Tree SSA -->
<!--  -->
</body></html>

